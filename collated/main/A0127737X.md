# A0127737X
###### \java\project\taskcrusher\commons\events\model\ListsToShowUpdatedEvent.java
``` java
/**
 * Used to notify the UI about the number of items in each list so that it can display them to the user.
 */
public class ListsToShowUpdatedEvent extends BaseEvent {

    public final int eventCount;
    public final int taskCount;

    public ListsToShowUpdatedEvent(int eventCount, int taskCount) {
        this.eventCount = eventCount;
        this.taskCount = taskCount;
    }

    @Override
    public String toString() {
        return "eventCount =  " + eventCount + " taskCount =  " + taskCount;
    }

}
```
###### \java\project\taskcrusher\commons\events\model\TimerToUpdateEvent.java
``` java
/**
 * This event is used to notify the UI to update the timer used to check overdue status of events and tasks
 * that it displays. This event is to be raised every time before the user action updates the filteredLists.
 */
public class TimerToUpdateEvent extends BaseEvent {

    public TimerToUpdateEvent () {
    }

    @Override
    public String toString() {
        return "Timer to update BEFORE the list gets filtered";
    }

}
```
###### \java\project\taskcrusher\commons\util\StringUtil.java
``` java
    public static boolean containsSubstringIgnoreCase(String sentence, String string) {
        assert string != null : "String parameter cannot be null";
        assert sentence != null : "Sentence parameter cannot be null";

        String preppedWord = string.trim().toLowerCase();
        assert !preppedWord.isEmpty() : "Word parameter cannot be empty";
        assert preppedWord.split("\\s+").length == 1 : "String parameter should be a single string";

        String preppedSentence = sentence;
        String[] wordsInPreppedSentence = preppedSentence.split("\\s+");

        for (String wordInSentence: wordsInPreppedSentence) {
            if (wordInSentence.toLowerCase().contains(preppedWord)) return true;
        }
        return false;
    }

```
###### \java\project\taskcrusher\commons\util\UiDisplayUtil.java
``` java
/**
 * This class provides the utility to adjust the displayed texts of some of the Event and Task attributes to cater
 * for better UI.
 */
public class UiDisplayUtil {
    public static final String[] PARSE_PATTERNS = { "MMM dd yyyy hh:mma", "EEEE hh:mma",
        "MMM dd hh:mma", "hh:mma" };
    public static final int FORMAT_DATE_ABSOLUTE = 0;
    public static final int FORMAT_DATE_THIS_WEEK = 1;
    public static final int FORMAT_DATE_THIS_YEAR = 2;
    public static final int FORMAT_DATE_RELATIVE = 3;
    public static final String MESSAGE_NO_DEADLINE = "no deadline";

    /**
     * returns a string representation of the given deadline in a user-friendly format for display
     */
    public static String renderDeadlineAsStringForUi(Deadline deadline) {
        assert deadline != null;
        if (!deadline.hasDeadline()) {
            return MESSAGE_NO_DEADLINE;
        }

        Date date = deadline.getDate().get();
        String deadlineFormat, prepend = "By ";

        if (isToday(date)) {
            deadlineFormat = PARSE_PATTERNS[FORMAT_DATE_RELATIVE];
            prepend += "Today ";
        } else if (isThisWeek(date)) {
            deadlineFormat = PARSE_PATTERNS[FORMAT_DATE_THIS_WEEK];
        } else if (isThisYear(date)) {
            deadlineFormat = PARSE_PATTERNS[FORMAT_DATE_THIS_YEAR];
        }  else {
            deadlineFormat = PARSE_PATTERNS[FORMAT_DATE_ABSOLUTE];
        }
        SimpleDateFormat formatter = new SimpleDateFormat(deadlineFormat, Locale.ENGLISH);
        return prepend + formatter.format(date);
    }

    private static boolean isThisYear(Date d) {
        Date now = new Date();
        SimpleDateFormat yearChecker = new SimpleDateFormat("yyyy");
        return yearChecker.format(now).equals(yearChecker.format(d));
    }

    private static boolean isToday(Date d) {
        Date now = new Date();
        SimpleDateFormat dateChecker = new SimpleDateFormat("yyyyMMdd");
        return dateChecker.format(now).equals(dateChecker.format(d));
    }

    private static boolean isThisWeek(Date d) {
        Calendar currentCalendar = Calendar.getInstance();
        int week = currentCalendar.get(Calendar.WEEK_OF_YEAR);
        Calendar targetCalendar = Calendar.getInstance();
        targetCalendar.setTime(d);
        int targetWeek = targetCalendar.get(Calendar.WEEK_OF_YEAR);
        return week == targetWeek;
    }

    /**
     * returns a string representation of the given time slot, with redundant details stripped for display
     */
    public static String renderTimeslotAsStringForUi(Timeslot timeslot) {
        assert timeslot != null;
        String endFormat, startFormat, startPrepend = "", endPrepend = "";

        /////endFormat
        if (isSameDate(timeslot.start, timeslot.end)) {
            endFormat = PARSE_PATTERNS[FORMAT_DATE_RELATIVE];
        } else if (isToday(timeslot.end)) {
            endFormat = PARSE_PATTERNS[FORMAT_DATE_RELATIVE];
            endPrepend += "Today ";
        } else if (isThisWeek(timeslot.end)) {
            endFormat = PARSE_PATTERNS[FORMAT_DATE_THIS_WEEK];
        } else if (isThisYear(timeslot.end)) {
            endFormat = PARSE_PATTERNS[FORMAT_DATE_THIS_YEAR];
        } else {
            endFormat = PARSE_PATTERNS[FORMAT_DATE_ABSOLUTE];
        }

        /////startFormat
        if (isToday(timeslot.start)) {
            startFormat = PARSE_PATTERNS[FORMAT_DATE_RELATIVE];
            startPrepend = "Today ";
        } else if (isThisWeek(timeslot.start)) {
            startFormat = PARSE_PATTERNS[FORMAT_DATE_THIS_WEEK];
        } else if (isThisYear(timeslot.start)) {
            startFormat = PARSE_PATTERNS[FORMAT_DATE_THIS_YEAR];
        } else {
            startFormat = PARSE_PATTERNS[FORMAT_DATE_ABSOLUTE];
        }

        SimpleDateFormat sdf = new SimpleDateFormat(startFormat, Locale.ENGLISH);
        startPrepend += sdf.format(timeslot.start) + " to ";
        sdf.applyPattern(endFormat);
        startPrepend += endPrepend + sdf.format(timeslot.end);
        return startPrepend;
    }

    private static boolean isSameDate(Date d1, Date d2) {
        SimpleDateFormat dateChecker = new SimpleDateFormat("yyyyMMdd");
        return dateChecker.format(d1).equals(dateChecker.format(d2));
    }

    public static String priorityForUi(Priority p) {
        return "p=" + p.priority;
    }

    public static String getLocationStringForUi(Location location) {
        return location.hasLocation() ? "@ " + location.location : "";
    }

}
```
###### \java\project\taskcrusher\logic\commands\LoadCommand.java
``` java
/** loads an xml storage file. The user may specify if he/she wants to create a missing file,
 *  by providing the word "new" before the filename. or load an existing xml file. The loading of new file
 *  is achieved by posting {@code LoadNewStorageFileEvent} which is handled at the high-level
 *  {@code MainApp} instance.
 */
public class LoadCommand extends Command {
    public static final String COMMAND_WORD = "load";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": loads an xml storage file with the name given\n"
            + "To create and load a new file, type in new before file name. Otherwise, it loads an existing file\n"
            + "Parameters: [new] XML_FILE_NAME";

    public static final String MESSAGE_LOAD_SUCCESS = "Loaded file %1$s";
    public static final String MESSAGE_INVALID_FILENAME = "Invalid file name given";
    public static final String MESSAGE_FILE_ALREADY_EXISTS = "The file %1$s already exists";
    public static final String MESSAGE_FILE_NONEXISTENT = "The file %1$s does not exist";
    public static final String MESSAGE_INVALID_EXTENSION = "Only xml files are supported for data storage";
    public static final String XML_EXTENSION = ".xml";
    public static final boolean IS_CREATE_NEW_FILE = true;

    public final String filenameToLoad;
    public final boolean isCreateNewFile;

    public LoadCommand(String filenameToLoad, boolean isCreateNewFile) {
        assert filenameToLoad != null;
        this.filenameToLoad = filenameToLoad;
        this.isCreateNewFile = isCreateNewFile;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (filenameToLoad.isEmpty()) {
            throw new CommandException(MESSAGE_USAGE);
        }
        if (!filenameToLoad.endsWith(XML_EXTENSION)) {
            throw new CommandException(MESSAGE_INVALID_EXTENSION);
        }

        if (isCreateNewFile) {
            if (FileUtil.isFileExists(new File(filenameToLoad))) {
                throw new CommandException(String.format(MESSAGE_FILE_ALREADY_EXISTS, filenameToLoad));
            } else {
                try {
                    FileUtil.createIfMissing(new File(filenameToLoad));
                } catch (IOException e) {
                    throw new CommandException(MESSAGE_INVALID_FILENAME);
                }
            }
        } else {
            if (!FileUtil.isFileExists(new File(filenameToLoad))) {
                throw new CommandException(String.format(MESSAGE_FILE_NONEXISTENT, filenameToLoad));
            }
        }

        raise (new LoadNewStorageFileEvent(filenameToLoad));
        return new CommandResult(String.format(MESSAGE_LOAD_SUCCESS, filenameToLoad));
    }

    private void raise(BaseEvent e) {
        EventsCenter.getInstance().post(e);
    }
}
```
###### \java\project\taskcrusher\logic\parser\LoadCommandParser.java
``` java
/**
 * Parses the arguments for load command. Also checks if the user wants to create a new file before loading.
 */
public class LoadCommandParser {

    public Command parse(String arguments) {
        String[] argElements = arguments.trim().split(" ");

        if (argElements.length == 1) {
            String filenameToLoad = argElements[0].trim();
            return new LoadCommand(filenameToLoad, !LoadCommand.IS_CREATE_NEW_FILE);
        } else if (argElements.length == 2) {
            String option = argElements[0].trim();
            if (option.equals("new")) {
                String filenameToLoad = argElements[1].trim();
                return new LoadCommand(filenameToLoad, LoadCommand.IS_CREATE_NEW_FILE);
            }
        }

        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, LoadCommand.MESSAGE_USAGE));
    }
}
```
###### \java\project\taskcrusher\MainApp.java
``` java
    @Subscribe
    public void handleLoadNewStorageFileEvent(LoadNewStorageFileEvent lnsfe) {
        logger.info("Attempting to change storage file to  " + lnsfe.filePathToLoad);
        String currentStorageFilePath = config.getUserInboxFilePath();
        try {
            setStoragePathInConfig(lnsfe.filePathToLoad);
        } catch (IOException e) {
            logger.warning(LoadNewStorageFileEvent.MESSAGE_LOAD_FAILED);
            config.setUserInboxFilePath(currentStorageFilePath); //set it back to old path
            return;
        }
        reinitialiseMainAppWithNewStorage(lnsfe.filePathToLoad);
        logger.info("New storage file successfully loaded");
    }

    private void setStoragePathInConfig(String newStorageFile) throws IOException {
        config.setUserInboxFilePath(newStorageFile);
        ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);
    }

    private void reinitialiseMainAppWithNewStorage(String newStorageFile) {
        EventsCenter.getInstance().unregisterHandler(storage);
        storage = new StorageManager(newStorageFile, config.getUserPrefsFilePath());
        model.resetData(loadInitialUserInboxFromStorage(storage));
        logic = new LogicManager(model, storage);
        ui.setLogic(logic);
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```
###### \java\project\taskcrusher\model\event\Event.java
``` java
/**
 * Represents a user event that is bound to one or more specific timeslots
 */
public class Event extends UserToDo implements ReadOnlyEvent {

    public static final String EVENT_FLAG = "e";

    private List<Timeslot> timeslots;
    private Location location;

    /**
     *  Constructor for event. {@code isComplete} is initially set to false.
     *  {@code timeslots} will be sorted from earliest start time to latest start time
     */
    public Event(Name name, List<Timeslot> timeslots, Priority priority, Location location, Description description,
            UniqueTagList tags) {
        super(name, priority, description, tags);

        assert !CollectionUtil.isAnyNull(timeslots, location);
        assert !timeslots.isEmpty();

        timeslots.sort(null);
        this.timeslots = timeslots;
        this.location = location;
    }

    /**
     *  Overloaded constructor for cases we want to specify {@code isComplete} field.
     */
    public Event(Name name, List<Timeslot> timeslots, Priority priority, Location location,
            Description description, UniqueTagList tags, boolean isComplete) {
        super(name, priority, description, tags);

        assert !CollectionUtil.isAnyNull(timeslots, location);

        this.timeslots = timeslots;
        this.location = location;
        this.isComplete = isComplete;
    }

    /**
     * Creates a copy of the given ReadOnlyEvent.
     */
    public Event(ReadOnlyEvent source) {
        this(source.getName(), source.getTimeslots(), source.getPriority(), source.getLocation(),
                source.getDescription(), source.getTags(), source.isComplete());
    }

    /**
     * Picks the timeslot specified by the {@code timeslotIndex} and removes the rest from {@code timeslots}.
     */
    public boolean confirmTimeslot(int timeslotIndex) {
        Timeslot confirmed = timeslots.get(timeslotIndex);

        //done this way to keep the data state for undo
        timeslots = new ArrayList<Timeslot>();
        timeslots.add(confirmed);
        return true;
    }

    public Date getEarliestBookedTime() {
        return timeslots.get(0).start;
    }

    public List<Timeslot> getTimeslots() {
        return this.timeslots;
    }

    public void setTimeslots(List<Timeslot> timeslots) {
        assert timeslots != null;
        timeslots.sort(null);
        this.timeslots = timeslots;
    }

    public Location getLocation() {
        return this.location;
    }

    public void setLocation(Location location) {
        assert location != null;
        this.location = location;
    }

    public boolean isOverdue(Date timer) {
        for (Timeslot timeslot : getTimeslots()) {
            if (timer.after(timeslot.end)) {
                return true;
            }
        }
        return false;
    }

    public void resetData(ReadOnlyEvent replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setTimeslots(replacement.getTimeslots());
        this.setPriority(replacement.getPriority());
        this.setLocation(replacement.getLocation());
        this.setDescription(replacement.getDescription());
        this.setTags(replacement.getTags());
        this.isComplete = replacement.isComplete();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyEvent // instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyEvent) other));
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, timeslots, location, description, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public int compareTo(ReadOnlyEvent another) {
        if (this.isComplete && !another.isComplete()) {
            return 1;
        } else if (!this.isComplete && another.isComplete()) {
            return -1;
        } else {
            //both are complete, or both are incomplete
            return this.getEarliestBookedTime().compareTo(another.getEarliestBookedTime());
        }
    }

    /**
     * Checks if any of the {@preexistingEvents} has overlapping start and end date with this event.
     */
    @Override
    public boolean hasOverlappingEvent(List<? extends ReadOnlyEvent> preexistingEvents) {
        for (ReadOnlyEvent event : preexistingEvents) {
            for (Timeslot timeslot : event.getTimeslots()) {
                if (this.hasOverlappingTimeslot(timeslot)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if {@code timeslot} has overlapping start and end date with the timeslots of this event.
     */
    @Override
    public boolean hasOverlappingTimeslot(Timeslot timeslot) {
        assert timeslot != null;
        for (Timeslot ts : timeslots) {
            if (ts.isOverlapping(timeslot)) {
                return true;
            }
        }
        return false;
    }

}
```
###### \java\project\taskcrusher\model\event\UniqueEventList.java
``` java
/**
 * stores a list of events that contain no duplicates. At any point in time, {@code internalList} is sorted
 * by the earliest timeslot of the events.
 *
 * @see Event#compareTo(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueEventList implements Iterable<Event> {

    private final ObservableList<Event> internalList = FXCollections.observableArrayList();

    public void sortEventsByEarliestTimeslot() {
        internalList.sort(null);
    }

    /**
     * Marks the event specified by {@code targetIndex} according to {@code markFlag}.
     */
    public void markEvent(int targetIndex, int markFlag) {
        Event target = internalList.get(targetIndex);
        if (markFlag == MarkCommand.MARK_COMPLETE) {
            target.markComplete();
        } else if (markFlag == MarkCommand.MARK_INCOMPLETE) {
            target.markIncomplete();
        } else {
            assert false;
        }
        sortEventsByEarliestTimeslot();
    }

    public void confirmEventTime(int eventListIndex, int timeslotIndex) {
        internalList.get(eventListIndex).confirmTimeslot(timeslotIndex);
        sortEventsByEarliestTimeslot();
    }

```
###### \java\project\taskcrusher\model\ModelManager.java
``` java
/**
 * Represents the in-memory model of the user inbox data.
 * All changes to any model should be synchronised.
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private final UserInbox userInbox;
    private final FilteredList<ReadOnlyTask> filteredTasks;
    private final FilteredList<ReadOnlyEvent> filteredEvents;
    private final Stack<UserInbox> undoStack;
    private final Stack<UserInbox> redoStack;
    private boolean isLastPerformedActionUndo;
    private boolean isLastSeenListsActiveLists; //to make the lists showing consistent after user actions

    /**
     * Initialises a ModelManager with the given userInbox and userPrefs.
     */
    public ModelManager(ReadOnlyUserInbox userInbox, UserPrefs userPrefs) {
        super();
        assert !CollectionUtil.isAnyNull(userInbox, userPrefs);

        logger.fine("Initializing with user inbox: " + userInbox + " and user prefs " + userPrefs);

        this.userInbox = new UserInbox(userInbox);
        filteredTasks = new FilteredList<>(this.userInbox.getTaskList());
        filteredEvents = new FilteredList<>(this.userInbox.getEventList());
        undoStack = new Stack<>();
        redoStack = new Stack<>();
        updateFilteredListsToShowAll();
    }

    public ModelManager() {
        this(new UserInbox(), new UserPrefs());
    }

```
###### \java\project\taskcrusher\model\ModelManager.java
``` java
    public void signalUiForUpdatedLists() {
        int eventCount = filteredEvents.size();
        int taskCount = filteredTasks.size();

        raise(new ListsToShowUpdatedEvent(eventCount, taskCount));
    }

    /**
     * For smooth user experience, unless specified, keep the format of the lists shown consistent
     * with what was previously shown before the user entered the command.
     */
    private void showAppropriateLists() {
        if (isLastSeenListsActiveLists) {
            updateFilteredListsToShowActiveToDo();
        } else {
            updateFilteredListsToShowAll();
        }
    }
    //=========== Task operations =========================================================================

    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        saveUserInboxStateForUndo();
        userInbox.removeTask(target);
        indicateUserInboxChanged();
        updateFilteredListsToShowActiveToDo();
        signalUiForUpdatedLists();
    }

    @Override
    public synchronized void addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
        saveUserInboxStateForUndo();
        userInbox.addTask(task);
        updateFilteredListsToShowActiveToDo();
        indicateUserInboxChanged();
    }

    @Override
    public synchronized void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedTask != null;
        saveUserInboxStateForUndo();
        int taskListIndex = filteredTasks.getSourceIndex(filteredTaskListIndex);
        userInbox.updateTask(taskListIndex, editedTask);
        showAppropriateLists();
        indicateUserInboxChanged();
    }

    @Override
    public synchronized void markTask(int filteredTaskListIndex, int markFlag) {
        saveUserInboxStateForUndo();
        userInbox.markTask(filteredTaskListIndex, markFlag);
        updateFilteredListsToShowAll();
        indicateUserInboxChanged();
    }

    @Override
    public synchronized void switchTaskToEvent(ReadOnlyTask toDelete, Event toAdd) throws
        DuplicateEventException, TaskNotFoundException {
        assert toDelete != null && toAdd != null;
        saveUserInboxStateForUndo();
        userInbox.removeTask(toDelete);
        userInbox.addEvent(toAdd);
        showAppropriateLists();
        indicateUserInboxChanged();
    }

    //=========== Event operations =========================================================================

    @Override
    public synchronized void deleteEvent(ReadOnlyEvent target) throws EventNotFoundException {
        saveUserInboxStateForUndo();
        userInbox.removeEvent(target);
        updateFilteredListsToShowActiveToDo();
        indicateUserInboxChanged();
    }

    @Override
    public synchronized void updateEvent(int filteredEventListIndex, ReadOnlyEvent editedEvent)
            throws DuplicateEventException {
        assert editedEvent != null;
        saveUserInboxStateForUndo();
        int eventListIndex = filteredEvents.getSourceIndex(filteredEventListIndex);
        userInbox.updateEvent(eventListIndex, editedEvent);
        showAppropriateLists();
        indicateUserInboxChanged();
    }

    @Override
    public synchronized void addEvent(Event event) throws DuplicateEventException {
        saveUserInboxStateForUndo();
        userInbox.addEvent(event);
        updateFilteredListsToShowActiveToDo();
        indicateUserInboxChanged();
    }

    @Override
    public synchronized void markEvent(int filteredEventListIndex, int markFlag) {
        saveUserInboxStateForUndo();
        userInbox.markEvent(filteredEventListIndex, markFlag);
        updateFilteredListsToShowAll();
        indicateUserInboxChanged();
    }

    @Override
    public synchronized void confirmEventTime(int filteredEventListIndex, int timeslotIndex) {
        saveUserInboxStateForUndo();
        int eventListIndex = filteredEvents.getSourceIndex(filteredEventListIndex);
        userInbox.confirmEventTime(eventListIndex, timeslotIndex);
        updateFilteredListsToShowActiveToDo();
        indicateUserInboxChanged();
    }

    @Override
    public synchronized void switchEventToTask(ReadOnlyEvent toDelete, Task toAdd) throws
        DuplicateTaskException, EventNotFoundException {
        assert toDelete != null && toAdd != null;
        saveUserInboxStateForUndo();
        userInbox.removeEvent(toDelete);
        userInbox.addTask(toAdd);
        showAppropriateLists();
        indicateUserInboxChanged();
    }

    @Override
    public void saveUserInboxStateForUndo() {
        undoStack.push(new UserInbox(this.userInbox));
        isLastPerformedActionUndo = false;
    }

    //=========== Filtered Task List Accessors =============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    //=========== Filtered Event List Accessors =============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyEvent> getFilteredEventList() {
        return new UnmodifiableObservableList<>(filteredEvents);
    }

    //=========== Combined filtering for UI =================================================================

    @Override
    public void updateFilteredListsToShowAll() {
        isLastSeenListsActiveLists = false;
        filteredEvents.setPredicate(null);
        filteredTasks.setPredicate(null);
        signalUiForUpdatedLists();
    }

    @Override
    public void updateFilteredListsToShowActiveToDo() {
        isLastSeenListsActiveLists = true;
        updateFilteredLists(new PredicateExpression(new CompletionQualifier(false)));
    }

    @Override
    public void updateFilteredListsToShowCompleteToDo() {
        isLastSeenListsActiveLists = false;
        updateFilteredLists(new PredicateExpression(new CompletionQualifier(true)));
    }

    @Override
    public void updateFilteredLists(Set<String> keywords, boolean showCompletedToo) {
        updateFilteredLists(new PredicateExpression(new KeywordQualifier(keywords, showCompletedToo)));
    }

    @Override
    public void updateFilteredLists(Timeslot userInterestedTimeslot) {
        isLastSeenListsActiveLists = true;
        updateFilteredLists(new PredicateExpression(new TimeslotQualifier(userInterestedTimeslot)));
    }

    private void updateFilteredLists(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
        filteredEvents.setPredicate(expression::satisfies);
        signalUiForUpdatedLists();
    }

    //========== Inner classes/interfaces used for filtering =================================================

    interface Expression {
        boolean satisfies(ReadOnlyUserToDo item);
        String toString();
    }

    private class PredicateExpression implements Expression {
        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyUserToDo item) {
            return qualifier.run(item);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyUserToDo item);
        String toString();
    }

    /**
     * Checks if {@code item} contains any of the keywords as substring in its name, description,
     * tags (and location if {@code item instanceof Event}).
     */
    private class KeywordQualifier implements Qualifier {
        private Set<String> keyWords;
        private boolean showCompletedItemsToo;

        KeywordQualifier(Set<String> keyWords, boolean showCompletedItemsToo) {
            this.keyWords = keyWords;
            this.showCompletedItemsToo = showCompletedItemsToo;
        }

        @Override
        public boolean run(ReadOnlyUserToDo item) {
            if (showCompletedItemsToo) {
                return keyWords.stream()
                    .filter(keyword -> StringUtil.containsSubstringIgnoreCase(item.toString(), keyword))
                    .findAny()
                    .isPresent();
            } else {
                return !item.isComplete() && keyWords.stream()
                        .filter(keyword -> StringUtil.containsSubstringIgnoreCase(item.toString(), keyword))
                        .findAny()
                        .isPresent();
            }
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", keyWords);
        }
    }

    /**
     * checks if:
     * 1. if the {@code item} is an active task, its deadline falls within {@code timeslot}
     * 2. if the {@code item} is an active event, any of its timeslots overlaps with {@code timeslot}
     */
    private class TimeslotQualifier implements Qualifier {
        private Timeslot userInterestedTimeslot;

        TimeslotQualifier(Timeslot timeslot) {
            assert timeslot != null;
            this.userInterestedTimeslot = timeslot;
        }

        @Override
        public boolean run(ReadOnlyUserToDo item) {
            if (item.isComplete()) {
                return false;
            } else if (item instanceof ReadOnlyEvent) {
                ReadOnlyEvent event = (ReadOnlyEvent) item;
                return event.hasOverlappingTimeslot(userInterestedTimeslot);
            } else if (item instanceof ReadOnlyTask) {
                ReadOnlyTask task = (ReadOnlyTask) item;
                return task.getDeadline().isWithin(userInterestedTimeslot);
            } else {
                assert false;
                return false;
            }
        }

        @Override
        public String toString() {
            return "user-interested timeslot is " + userInterestedTimeslot.toString();
        }
    }

    /**
     * checks if {@code item} is marked as complete or incomplete
     */
    private class CompletionQualifier implements Qualifier {
        private boolean showComplete;

        CompletionQualifier(boolean showComplete) {
            this.showComplete = showComplete;
        }

        @Override
        public boolean run(ReadOnlyUserToDo item) {
            if (item.isComplete()) {
                return this.showComplete ? true : false;
            }
            return this.showComplete ? false : true;
        }

        @Override
        public String toString() {
            return "separate between ongoing and completed tasks and events";
        }
    }
}
```
###### \java\project\taskcrusher\model\shared\ReadOnlyUserToDo.java
``` java
/**Parent interface of ReadOnlyEvent and ReadOnlyTask.
 */

public interface ReadOnlyUserToDo {

    Name getName();

    Priority getPriority();

    Description getDescription();

    /**
     * The returned TagList is a deep copy of the internal TagList,
     * changes on the returned list will not affect the task's internal tags.
     */
    UniqueTagList getTags();

    boolean isComplete();

    String toString();
}
```
###### \java\project\taskcrusher\model\shared\UserToDo.java
``` java
/** Acts as a parent class of Event and Task. Represents a ToDo that user is going to complete
 *  at/by "some point in time". There is no notion of time introduced at this level.
 */
public class UserToDo implements ReadOnlyUserToDo {
    protected Name name;
    protected Description description;
    protected Priority priority;
    protected UniqueTagList tags;
    protected boolean isComplete;

    /**
     * Creates a UserToDo with complete flag initially set to false.
     */
    public UserToDo (Name name, Priority priority, Description description, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, priority, description, tags);

        this.name = name;
        this.priority = priority;
        this.description = description;
        this.tags = new UniqueTagList(tags);
        this.isComplete = false;
    }

    @Override
    public Name getName() {
        return name;
    }

    public void setName(Name name) {
        this.name = name;
    }

    @Override
    public Description getDescription() {
        return description;
    }

    public void setDescription(Description description) {
        this.description = description;
    }

    @Override
    public Priority getPriority() {
        return priority;
    }

    public void setPriority(Priority priority) {
        this.priority = priority;
    }

    @Override
    public UniqueTagList getTags() {
        return tags;
    }

    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    @Override
    public boolean isComplete() {
        return this.isComplete;
    }

    public void markComplete() {
        this.isComplete = true;
    }

    public void markIncomplete() {
        this.isComplete = false;
    }
}
```
###### \java\project\taskcrusher\model\task\Task.java
``` java
/**
 * Represents an active task. Guarantees: details are present and not null (just
 * empty in <Optional>), field values are validated.
 */
public class Task extends UserToDo implements ReadOnlyTask {

    public static final String TASK_FLAG = "t";

    private Deadline deadline;

    /**
     * Constructor for Task. {@code isComplete} is initially set to false.
     */
    public Task(Name name, Deadline deadline, Priority priority, Description description, UniqueTagList tags) {
        super(name, priority, description, tags);
        assert deadline != null;

        this.deadline = deadline;
    }

    /**
     * Overloaded constructor for cases we want to specify {@code isComplete} field.
     */
    public Task(Name name, Deadline deadline, Priority priority, Description description, UniqueTagList tags,
            boolean isComplete) {
        super(name, priority, description, tags);
        assert deadline != null;

        this.deadline = deadline;
        this.isComplete = isComplete;
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getDeadline(), source.getPriority(), source.getDescription(),
                source.getTags(), source.isComplete());
    }

    @Override
    public Deadline getDeadline() {
        return deadline;
    }

    public void setDeadline(Deadline deadline) {
        assert deadline != null;
        this.deadline = deadline;
    }

    public boolean hasDeadline() {
        return this.deadline.hasDeadline();
    }

    @Override
    public boolean isOverdue(Date timer) {
        return hasDeadline() && timer.after(getDeadline().getDate().get());
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setPriority(replacement.getPriority());
        this.setDeadline(replacement.getDeadline());
        this.setDescription(replacement.getDescription());
        this.setTags(replacement.getTags());
        this.isComplete = replacement.isComplete();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, deadline, priority, description, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public int compareTo(ReadOnlyTask another) {
        if (this.isComplete && !another.isComplete()) {
            return 1;
        } else if (!this.isComplete && another.isComplete()) {
            return -1;
        } else {
            //both are complete, or both are incomplete
            if (!this.getDeadline().hasDeadline() && !another.getDeadline().hasDeadline()) {
                return this.getPriority().compareTo(another.getPriority());
            } else if (!this.getDeadline().hasDeadline() && another.getDeadline().hasDeadline()) {
                return 1;
            } else if (this.getDeadline().hasDeadline() && !another.getDeadline().hasDeadline()) {
                return -1;
            } else {
                //both has deadline
                Date thisDate = this.getDeadline().getDate().get();
                assert thisDate != null;
                Date anotherDate = another.getDeadline().getDate().get();
                assert anotherDate != null;
                return thisDate.compareTo(anotherDate);
            }
        }
    }

}
```
###### \java\project\taskcrusher\model\task\UniqueTaskList.java
``` java
/**
 * A list of tasks that enforces uniqueness between its elements and does not allow nulls.
 * At any point in time, {@code internalList} is sorted by the deadline.
 * Supports a minimal set of list operations.
 *
 * @see Task#compareTo(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueTaskList implements Iterable<Task> {

    private final ObservableList<Task> internalList = FXCollections.observableArrayList();

    public void sortTasksByDeadline () {
        internalList.sort(null);
    }

    /**
     * Marks the task specified by {@code targetIndex} according to {@code markFlag}.
     */
    public void markTask(int targetIndex, int markFlag) {
        Task target = internalList.get(targetIndex);
        if (markFlag == MarkCommand.MARK_COMPLETE) {
            target.markComplete();
        } else if (markFlag == MarkCommand.MARK_INCOMPLETE) {
            target.markIncomplete();
        } else {
            assert false;
        }
        sortTasksByDeadline();
    }

```
###### \java\project\taskcrusher\model\UserInbox.java
``` java
    public void markTask(int index, int markFlag) {
        tasks.markTask(index, markFlag);
    }

    public void markEvent(int index, int markFlag) {
        events.markEvent(index, markFlag);
    }

    public void confirmEventTime(int eventListIndex, int timeslotIndex) {
        events.confirmEventTime(eventListIndex, timeslotIndex);
    }

    //@author

    //// task-level operations

    /**
     * Adds a task to the user inbox.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task p) throws UniqueTaskList.DuplicateTaskException {
        syncMasterTagListWith(p);
        tasks.add(p);
    }

    /**
     * Updates the task in the list at position {@code index} with {@code editedReadOnlyPerson}.
     * {@code AddressBook}'s tag list will be updated with the tags of {@code editedReadOnlyPerson}.
     * @see #syncMasterTagListWith(Task)
     *
     * @throws DuplicateTaskException if updating the task's details causes the task to be equivalent to
     *      another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void updateTask(int index, ReadOnlyTask editedReadOnlyTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedReadOnlyTask != null;

        Task editedTask = new Task(editedReadOnlyTask);
        syncMasterTagListWith(editedTask);
        // TODO: the tags master list will be updated even though the below line fails.
        // This can cause the tags master list to have additional tags that are not tagged to any task
        // in the task list.
        tasks.updateTask(index, editedTask);
    }

    public boolean removeTask(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.remove(key)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }

    /**
     * Ensures that every tag in this task:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     */
    private void syncMasterTagListWith(Task task) {
        final UniqueTagList taskTags = task.getTags();
        tags.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        // used for checking person tag references
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        tags.forEach(tag -> masterTagObjects.put(tag, tag));

        // Rebuild the list of person tags to point to the relevant tags in the master tag list.
        final Set<Tag> correctTagReferences = new HashSet<>();
        taskTags.forEach(tag -> correctTagReferences.add(masterTagObjects.get(tag)));
        task.setTags(new UniqueTagList(correctTagReferences));
    }

    /**
     * Ensures that every tag in these tasks:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     *  @see #syncMasterTagListWith(Task)
     */
    private void syncMasterTagListWith(UniqueTaskList tasks) {
        tasks.forEach(this::syncMasterTagListWith);
    }

    /**
     * Ensures that every tag in this task:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     */
    private void syncMasterTagListWith(Event event) {
        final UniqueTagList eventTags = event.getTags();
        tags.mergeFrom(eventTags);

        // Create map with values = tag object references in the master list
        // used for checking person tag references
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        tags.forEach(tag -> masterTagObjects.put(tag, tag));

        // Rebuild the list of person tags to point to the relevant tags in the master tag list.
        final Set<Tag> correctTagReferences = new HashSet<>();
        eventTags.forEach(tag -> correctTagReferences.add(masterTagObjects.get(tag)));
        event.setTags(new UniqueTagList(correctTagReferences));
    }

    /**
     * Ensures that every tag in these tasks:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     *  @see #syncMasterTagListWith(Task)
     */
    private void syncMasterTagListWith(UniqueEventList events) {
        events.forEach(this::syncMasterTagListWith);
    }

    //// event-level operations

    /**
     * Adds a task to the user inbox.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addEvent(Event e) throws UniqueEventList.DuplicateEventException {
        syncMasterTagListWith(e);
        events.add(e);
    }

    /**
     * Updates the task in the list at position {@code index} with {@code editedReadOnlyPerson}.
     * {@code AddressBook}'s tag list will be updated with the tags of {@code editedReadOnlyPerson}.
     * @see #syncMasterTagListWith(Task)
     *
     * @throws DuplicateTaskException if updating the task's details causes the task to be equivalent to
     *      another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void updateEvent(int index, ReadOnlyEvent editedReadOnlyEvent)
            throws UniqueEventList.DuplicateEventException {
        assert editedReadOnlyEvent != null;

        Event editedEvent = new Event(editedReadOnlyEvent);
        syncMasterTagListWith(editedEvent);
        // TODO: the tags master list will be updated even though the below line fails.
        // This can cause the tags master list to have additional tags that are not tagged to any task
        // in the task list.
        events.updateEvent(index, editedEvent);
    }

    public boolean removeEvent(ReadOnlyEvent key) throws UniqueEventList.EventNotFoundException {
        if (events.remove(key)) {
            return true;
        } else {
            throw new UniqueEventList.EventNotFoundException();
        }
    }

    //// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

    //// util methods

    @Override
    public String toString() {
        return tasks.asObservableList().size() + " tasks, " + events.asObservableList().size() +
                "events, " + tags.asObservableList().size() +  " tags";
        // TODO: refine later
    }

    @Override
    public ObservableList<ReadOnlyTask> getTaskList() {
        return new UnmodifiableObservableList<>(tasks.asObservableList());
    }

    @Override
    public ObservableList<ReadOnlyEvent> getEventList() {
        return new UnmodifiableObservableList<>(events.asObservableList());
    }

    @Override
    public ObservableList<Tag> getTagList() {
        return new UnmodifiableObservableList<>(tags.asObservableList());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UserInbox // instanceof handles nulls
                        && this.tasks.equals(((UserInbox) other).tasks)
                        && this.events.equals(((UserInbox) other).events)
                        && this.tags.equalsOrderInsensitive(((UserInbox) other).tags));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasks, events, tags);
    }


}
```
###### \java\project\taskcrusher\storage\XmlAdaptedEvent.java
``` java
/**
 * JAXB-friendly version of Event.
 */
public class XmlAdaptedEvent {

    /* Attributes inherited from UserToDo*/
    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String priority;
    @XmlElement(required = true)
    private String description;
    @XmlElement(required = true)
    private boolean isComplete;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /* Event-specific attributes */
    @XmlElement(required = true)
    private List<XmlAdaptedTimeslot> timeslots = new ArrayList<>();
    @XmlElement(required = true)
    private String location;

    /**
     * Constructs an XmlAdaptedEvent.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedEvent() {}


    /**
     * Converts a given Event into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedEvent
     */
    public XmlAdaptedEvent(ReadOnlyEvent source) {
        name = source.getName().name;
        priority = source.getPriority().priority;
        description = source.getDescription().description;
        isComplete = source.isComplete();

        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }

        timeslots = new ArrayList<>();
        for (Timeslot timeslot: source.getTimeslots()) {
            timeslots.add(new XmlAdaptedTimeslot(timeslot));
        }

        location = source.getLocation().location;
    }

    /**
     * Converts this jaxb-friendly adapted event object into the model's Event object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted event
     */
    public Event toModelType() throws IllegalValueException {
        final List<Tag> eventTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            eventTags.add(tag.toModelType());
        }

        final List<Timeslot> eventTimeslots = new ArrayList<>();
        for (XmlAdaptedTimeslot timeslot: timeslots) {
            eventTimeslots.add(timeslot.toModelType());
        }

        final Name name = new Name(this.name);
        final Priority priority = new Priority(this.priority);
        final Description description = new Description(this.description);
        final UniqueTagList tags = new UniqueTagList(eventTags);

        final Location location = new Location(this.location);

        return new Event(name, eventTimeslots, priority, location, description, tags, isComplete);
    }

}
```
###### \java\project\taskcrusher\storage\XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of Task.
 */
public class XmlAdaptedTask {

    /* Attributes inherited from UserToDo*/
    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String priority;
    @XmlElement(required = true)
    private String description;
    @XmlElement(required = true)
    private boolean isComplete;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /* Task-specific attributes */
    @XmlElement(required = true)
    private String deadline;

    /**
     * Constructs an XmlAdaptedTask.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().name;
        priority = source.getPriority().priority;
        description = source.getDescription().description;
        isComplete = source.isComplete();

        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }

        deadline = source.getDeadline().deadline;
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }

        final Name name = new Name(this.name);
        final Priority priority = new Priority(this.priority);
        final Description description = new Description(this.description);
        final UniqueTagList tags = new UniqueTagList(taskTags);

        final Deadline deadline = new Deadline(this.deadline);
        return new Task(name, deadline, priority, description, tags, isComplete);
    }
}
```
###### \java\project\taskcrusher\storage\XmlAdaptedTimeslot.java
``` java
/**
 * JAXB-friendly version of Timeslot.
 */
public class XmlAdaptedTimeslot {

    @XmlElement(required = true)
    public String startDate;
    @XmlElement(required = true)
    public String endDate;

    /**
     * Constructs an XmlAdaptedTimeslot.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTimeslot() {}

    /**
     * Converts a given Timeslot into this class for JAXB use.
     */
    public XmlAdaptedTimeslot(Timeslot timeslot) {
        startDate = DateUtil.getDateAsStringForStorage(timeslot.start);
        endDate = DateUtil.getDateAsStringForStorage(timeslot.end);
    }

    /**
     * Converts this jaxb-friendly adapted timeslot object into the model's timeslot object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted timeslot
     */
    public Timeslot toModelType() throws IllegalValueException {
        return new Timeslot(startDate, endDate);
    }
}
```
###### \java\project\taskcrusher\ui\EventListCard.java
``` java
/**
 * Controller for EventListCard.fxml. Reads a ReadOnlyEvent and create the layout accordingly.
 */
public class EventListCard extends UiPart<Region> {

    private static final String FXML = "EventListCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label id;
    @FXML
    private Label name;
    @FXML
    private Label eventLocation; //named like this to avoid collision with the built-in "location" element
    @FXML
    private Label description;
    @FXML
    private Label priority;
    @FXML
    private FlowPane timeslots;
    @FXML
    private FlowPane tags;
    @FXML
    private ImageView tickIcon;
    @FXML
    private ImageView overdueIcon;

    public EventListCard(ReadOnlyEvent event, int displayedIndex, boolean isOverdue) {
        super(FXML);
        showId(displayedIndex);
        showName(event);
        showLocationIfAny(event);
        showDescription(event);
        showPriority(event);
        showEventTimeSlots(event);
        showCompleteStatusIfApplicable(event);
        showOverdueStatusIfApplicable(event, isOverdue);

        initTags(event);
    }

    private void showId(int displayedIndex) {
        id.setText(displayedIndex + ". ");
    }

    private void showName(ReadOnlyEvent event) {
        name.setText(event.getName().name);
//        name.setMinWidth(Region.USE_PREF_SIZE);
    }

    private void showCompleteStatusIfApplicable(ReadOnlyEvent event) {
        if (!event.isComplete()) {
            tickIcon.setVisible(false);
        }
    }

    private void showOverdueStatusIfApplicable(ReadOnlyEvent event, boolean isOverdue) {
        if (!event.isComplete() && isOverdue) {
            overdueIcon.setVisible(true);
            overdueIcon.setManaged(true);
            for (Node child: timeslots.getChildren()) {
                child.setStyle("-fx-text-fill: red"); //done this way to overwrite the CSS properties
            }
        } else {
            overdueIcon.setVisible(false);
            overdueIcon.setManaged(false);
        }
    }

    private void showDescription(ReadOnlyEvent event) {
        description.setText(event.getDescription().description);
        if (!event.getDescription().hasDescription()) {
            description.setVisible(false);
        }
    }

    private void showPriority(ReadOnlyEvent event) {
        priority.setText(UiDisplayUtil.priorityForUi(event.getPriority()));
        switch (event.getPriority().priority) {
        case "1":
            priority.getStyleClass().add("priority-one");
            break;
        case "2":
            priority.getStyleClass().add("priority-two");
            break;
        case "3":
            priority.getStyleClass().add("priority-three");
            break;
        default:
            priority.setVisible(false);
        }
        priority.setMinWidth(Region.USE_PREF_SIZE);
    }

    private void showLocationIfAny(ReadOnlyEvent event) {
        eventLocation.setText(UiDisplayUtil.getLocationStringForUi(event.getLocation()));
        if (event.getLocation().hasLocation()) {
            eventLocation.setMinWidth(Region.USE_PREF_SIZE);
        } else {
            eventLocation.setVisible(false);
            eventLocation.setManaged(false);
        }
    }

    private void showEventTimeSlots(ReadOnlyEvent event) {
        event.getTimeslots().forEach(timeslot -> timeslots.getChildren().add(new Label(
                UiDisplayUtil.renderTimeslotAsStringForUi(timeslot))));
    }

    private void initTags(ReadOnlyEvent event) {
        event.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }
}
```
###### \java\project\taskcrusher\ui\TaskListCard.java
``` java
/**
 * Controller for TaskListCard.fxml. Reads a ReadOnlyTask and create the layout accordingly.
 */
public class TaskListCard extends UiPart<Region> {

    private static final String FXML = "TaskListCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label id;
    @FXML
    private Label name;
    @FXML
    private Label priority;
    @FXML
    private Label deadline;
    @FXML
    private Label description;
    @FXML
    private FlowPane tags;
    @FXML
    private ImageView tickIcon;
    @FXML
    private ImageView overdueIcon;

    public TaskListCard(ReadOnlyTask task, int displayedIndex, boolean isOverdue) {
        super(FXML);
        showId(displayedIndex);
        showName(task);
        showPriorityIfAny(task);
        showDeadline(task);
        showDescriptionIfAny(task);
        showCompleteTickIfApplicable(task);
        showOverdueStatusIfApplicable(task, isOverdue);

        initTags(task);
    }

    private void showId(int displayedIndex) {
        id.setText(displayedIndex + ". ");
    }

    private void showName(ReadOnlyTask task) {
        name.setText(task.getName().name);
//        name.setMinWidth(Region.USE_PREF_SIZE);
    }

    private void showCompleteTickIfApplicable(ReadOnlyTask task) {
        if (!task.isComplete()) {
            tickIcon.setVisible(false);
        }
    }

    private void showOverdueStatusIfApplicable(ReadOnlyTask task, boolean isOverdue) {
        if (!task.isComplete() && isOverdue) {
            overdueIcon.setVisible(true);
            overdueIcon.setManaged(true);
            deadline.setStyle("-fx-text-fill: red"); //done this way to overwrite the CSS properties
        } else {
            overdueIcon.setVisible(false);
            overdueIcon.setManaged(false);
        }
    }

    private void showDescriptionIfAny(ReadOnlyTask task) {
        description.setText(task.getDescription().toString()); //still set the text even if empty for GuiTest
        if (!task.getDescription().hasDescription()) {
            description.setVisible(false);;
        }
    }

    private void showPriorityIfAny(ReadOnlyTask task) {
        priority.setText(UiDisplayUtil.priorityForUi(task.getPriority()));
        switch (task.getPriority().priority) {
        case "1":
            priority.getStyleClass().add("priority-one");
            break;
        case "2":
            priority.getStyleClass().add("priority-two");
            break;
        case "3":
            priority.getStyleClass().add("priority-three");
            break;
        default:
            priority.setVisible(false);
            priority.setManaged(false);
        }
        priority.setMinWidth(Region.USE_PREF_SIZE);
    }

    private void showDeadline(ReadOnlyTask task) {
        deadline.setText(UiDisplayUtil.renderDeadlineAsStringForUi(task.getDeadline()));
        deadline.setMinWidth(Region.USE_PREF_SIZE);
    }

    private void initTags(ReadOnlyTask person) {
        person.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }
}
```
###### \java\project\taskcrusher\ui\UserInboxPanel.java
``` java
/**
 * Panel containing the eventList and taskList.
 */
public class UserInboxPanel extends UiPart<Region> {
    private final Logger logger = LogsCenter.getLogger(UserInboxPanel.class);
    private static final String FXML = "UserInboxPanel.fxml";
    private static final boolean SET_LIST_VISIBLE = true;
    private static final boolean SET_LIST_HIDDEN = false;
    private static final String MESSAGE_NO_ITEM_TO_SHOW = "Nothing to show!";
    private Date timer; //used to check events' and tasks' overdue status

    @FXML
    private Label taskHeader;
    @FXML
    private ListView<ReadOnlyTask> taskListView;
    @FXML
    private Label eventHeader;
    @FXML
    private ListView<ReadOnlyEvent> eventListView;


    public UserInboxPanel(AnchorPane userInboxPlaceholder, ObservableList<ReadOnlyTask> taskList,
            ObservableList<ReadOnlyEvent> eventList) {
        super(FXML);
        timer = new Date();
        setConnections(taskList, eventList);
        addToPlaceholder(userInboxPlaceholder);
        registerAsAnEventHandler(this);
    }

    private void setConnections(ObservableList<ReadOnlyTask> taskList, ObservableList<ReadOnlyEvent> eventList) {
        taskListView.setItems(taskList);
        eventListView.setItems(eventList);
        taskListView.setCellFactory(listView -> new TaskListViewCell());
        eventListView.setCellFactory(listView -> new EventListViewCell());
    }

    private void addToPlaceholder(AnchorPane placeHolderPane) {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolderPane.getChildren().add(getRoot());
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(new TaskListCard(task, getIndex() + 1, task.isOverdue(timer)).getRoot());
            }
        }
    }

    class EventListViewCell extends ListCell<ReadOnlyEvent> {

        @Override
        protected void updateItem(ReadOnlyEvent event, boolean empty) {
            super.updateItem(event, empty);

            if (empty || event == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(new EventListCard(event, getIndex() + 1, event.isOverdue(timer)).getRoot());
            }
        }
    }

    @Subscribe
    public void handleListsToShowUpdatedEvent(ListsToShowUpdatedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        if (event.eventCount == 0) {
            eventListView.setVisible(SET_LIST_HIDDEN);
            eventHeader.setText("Events: " + MESSAGE_NO_ITEM_TO_SHOW);
        } else {
            eventListView.setVisible(SET_LIST_VISIBLE);
            eventHeader.setText("Events: " + event.eventCount + " listed");
        }

        if (event.taskCount == 0) {
            taskListView.setVisible(SET_LIST_HIDDEN);
            taskHeader.setText("Tasks: " + MESSAGE_NO_ITEM_TO_SHOW);
        } else {
            taskListView.setVisible(SET_LIST_VISIBLE);
            taskHeader.setText("Tasks: " + event.taskCount + " listed");
        }
    }

    @Subscribe
    public void handleTimerToUpdateEvent(TimerToUpdateEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        logger.info("Updated timer now at " + timer.toString());
        this.timer = new Date();
    }

}
```
###### \resources\view\DarkTheme.css
``` css

/*padding added to align tags vertically with the name */
#tags {
    -fx-hgap: 7;
    -fx-vgap: 2;
    -fx-padding: 3 0 0 0;
}

#tags .label {
    -fx-text-fill: white;
    -fx-background-color: #205077;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 13;
}

/*for the header labels */

.list_header {
    -fx-text-fill: black;
    -fx-padding: 3 10 7 10;
    -fx-font-size: 17px;
}

#name {
    -fx-padding: 0 10 0 5;
    -fx-min-width: 300px;
    -fx-max-width: 300px;
}

#timeslots {
    -fx-hgap: 7;
    -fx-vgap: 2;
}

#description {
    -fx-font-size: 13px;
    -fx-text-fill: #252c36;
    -fx-padding: 0 0 0 0;
}

#eventLocation {
    -fx-font-size: 13px;
    -fx-text-fill: #252c36;
    -fx-padding: 0 0 0 0;
}

.priority {
    -fx-text-fill: white;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 12;
}

.priority-one {
    -fx-background-color: derive(#fff54e, 30%);
}

.priority-two {
    -fx-background-color: derive(#ffbd00, 30%);
}

.priority-three {
    -fx-background-color: derive(#ff3f36, 30%);
}

#timeslots .label, #deadline {
    -fx-text-fill: black;
    -fx-background-color: derive(#d3d8e4, 10%);
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 12.5;
}

#resultDisplayPlaceholder {
    -fx-min-height: 103px;
}

#taskListView, #eventListView {
    -fx-min-width: 400px;
}

```
###### \resources\view\EventListCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT" minHeight="50.0" GridPane.columnIndex="0">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>
                    <children>
                        <HBox spacing="5" alignment="CENTER_LEFT">
                            <Label fx:id="id" styleClass="cell_big_label">
                                <minWidth>
                                      <Region fx:constant="USE_PREF_SIZE" />
                                </minWidth>
                            </Label>
                            <ImageView fx:id="overdueIcon" fitHeight="16.0" fitWidth="16.0">
                                <image>
                                    <Image url = "images/overdue.png" ></Image>
                                </image>
                            </ImageView>
                            <Label fx:id="name" wrapText="true" text="\$event_name" styleClass="cell_big_label"/>
                            <Label fx:id="priority" styleClass="priority" text="\$priority" />
                            <FlowPane fx:id="tags" />
                            <ImageView fx:id="tickIcon" fitHeight="25.0" fitWidth="25.0">
                            <image>
                                <Image url = "images/tick_icon.png" ></Image>
                            </image>
                            </ImageView>
                        </HBox>
                        <FlowPane fx:id="timeslots" styleClass = "timeslots"/>
                        <HBox spacing="20" alignment="CENTER_LEFT">
                        <Label fx:id="eventLocation" text="\$location" />
                        <Label fx:id="description" wrapText="true" text="\$description" />
                        </HBox>
                    </children>
                </VBox>
            </children>
        </GridPane>
    </children>
</HBox>
```
###### \resources\view\TaskListCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT" minHeight="45.0" GridPane.columnIndex="0">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>
                    <children>
                        <HBox alignment="CENTER_LEFT" spacing="5">
                            <children>
                                <Label fx:id="id" styleClass="cell_big_label">
                                    <minWidth>
                                      <Region fx:constant="USE_PREF_SIZE" />
                                    </minWidth>
                                </Label>
                                <ImageView fx:id="overdueIcon" fitHeight="16.0" fitWidth="16.0">
                                    <image>
                                        <Image url = "images/overdue.png" ></Image>
                                    </image>
                                </ImageView>
                                <Label fx:id="name" wrapText="true" styleClass="cell_big_label" text="\$first" />
                                <Label fx:id="priority" styleClass="priority" text="\$priority" />
                                <FlowPane fx:id="tags" />
                                <ImageView fx:id="tickIcon" fitHeight="25.0" fitWidth="25.0">
                                    <image>
                                        <Image url = "images/tick_icon.png" ></Image>
                                    </image>
                                </ImageView>
                            </children>
                        </HBox>
                        <Label fx:id="deadline" text="\$deadline" />
                        <Label fx:id="description" wrapText="true" text="\$description" />
                    </children>
                </VBox>
            </children>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
###### \resources\view\UserInboxPanel.fxml
``` fxml
<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
        <SplitPane fx:id="listSplitter" dividerPositions="0.5" VBox.vgrow="ALWAYS">
            <items>
                <VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
                    <padding>
                        <Insets bottom="0" left="5" right="8" top="0" />
                    </padding>
                    <children>
                        <Label fx:id="taskHeader" text="Tasks: " styleClass="list_header">
                            <graphic>
                                <ImageView fitHeight="23.0" fitWidth="23.0">
                                    <image>
                                        <Image url="images/sand_glass_icon.png"></Image>
                                    </image>
                                </ImageView>
                            </graphic>
                        </Label>
                        <ListView fx:id="taskListView" VBox.vgrow="ALWAYS" />
                    </children>
                </VBox>
                <VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
                    <padding>
                        <Insets bottom="0" left="8" right="5" top="0" />
                    </padding>
                    <children>
                        <Label fx:id="eventHeader" text="Events: " styleClass="list_header">
                            <graphic>
                                <ImageView fitHeight="23.0" fitWidth="23.0">
                                    <image>
                                        <Image url="images/calendar.png"></Image>
                                    </image>
                                </ImageView>
                            </graphic>
                        </Label>
                        <ListView fx:id="eventListView" VBox.vgrow="ALWAYS" />
                    </children>
                </VBox>
            </items>
        </SplitPane>
    </children>
</VBox>
```
